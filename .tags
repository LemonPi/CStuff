!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADMIN	.\stupidoop.h	/^	REGULAR, PREMIUM, ADMIN, SUPERADMIN$/;"	m	class:User_type
Adj_iter	.\stupidgraph.h	/^	struct Adj_iter {$/;"	s	class:Static_graph
BST	.\stupidgraph.h	/^	BST() : root{nullptr} {};$/;"	f	class:BST
BST	.\stupidgraph.h	/^class BST {$/;"	c
Binary_node	.\node.h	/^	Binary_node(int d) : data{d} {}$/;"	f	struct:Binary_node
Binary_node	.\node.h	/^struct Binary_node {$/;"	s
Blackjack_card	.\stupidoop.h	/^	Blackjack_card(int v, Suit s) : Card{v, s} {}$/;"	f	class:Blackjack_card
Blackjack_card	.\stupidoop.h	/^class Blackjack_card : public Card {$/;"	c
Book	.\stupidoop.h	/^	Book() : id{invalid} {}$/;"	f	class:Book
Book	.\stupidoop.h	/^	Book(long long i, double p, std::string&& c) :$/;"	f	class:Book
Book	.\stupidoop.h	/^class Book {$/;"	c
Call	.\stupidoop.h	/^class Response {}; class Call {};$/;"	c
Call_handler	.\stupidoop.h	/^class Call_handler {$/;"	c
Callcenter	.\stupidoop.h	/^	Callcenter(Tech_lead&& tl, Product_manager&& pm) : tech_lead{tl}, product_manager{pm} {}$/;"	f	class:Callcenter
Callcenter	.\stupidoop.h	/^class Callcenter {$/;"	c
Card	.\stupidoop.h	/^	Card(int v, Suit s) : val{v}, suit{s} {}$/;"	f	class:Card
Card	.\stupidoop.h	/^class Card {$/;"	c
DFS	.\stupidgraph.h	/^enum class DFS : char {$/;"	c
DIAMONDS	.\stupidoop.h	/^	HEARTS, SPADES, DIAMONDS, CLUBS$/;"	m	class:Suit
EXPLORING	.\stupidgraph.h	/^	UNEXPLORED = 0, EXPLORING, EXPLORED$/;"	m	class:DFS
Edge	.\stupidgraph.h	/^		Edge(int d, int w) : dest{d}, weight{w} {}$/;"	f	struct:Static_graph::Edge
Edge	.\stupidgraph.h	/^	struct Edge {$/;"	s	class:Static_graph
Employee	.\stupidoop.h	/^	Employee() {}	\/\/ default constructor in case derived classes need to be put into container$/;"	f	class:Employee
Employee	.\stupidoop.h	/^	Employee(const std::string& n, size_t i) : name{n}, id{i}, busy{false} {}$/;"	f	class:Employee
Employee	.\stupidoop.h	/^class Employee : public Call_handler {$/;"	c
Fresher	.\stupidoop.h	/^	Fresher() : Employee{}, workplace{nullptr} {}$/;"	f	class:Fresher
Fresher	.\stupidoop.h	/^	Fresher(const std::string& n, size_t i, Callcenter* w) : Employee{n,i}, workplace{w} {}$/;"	f	class:Fresher
Fresher	.\stupidoop.h	/^class Fresher : public Employee {$/;"	c
GETINPUT	.\stupidbits.h	8;"	d
HEARTS	.\stupidoop.h	/^	HEARTS, SPADES, DIAMONDS, CLUBS$/;"	m	class:Suit
Hanoi_towers	.\stupidstack.h	/^	Hanoi_towers(size_t N) : towers(3), game_size{N}, moves_taken{0} {$/;"	f	class:Hanoi_towers
Hanoi_towers	.\stupidstack.h	/^class Hanoi_towers {$/;"	c
Id_hash	.\stupidoop.h	/^struct Id_hash {$/;"	s
Library	.\stupidoop.h	/^class Library {$/;"	c
Linked_node	.\node.h	/^	Linked_node(value_type val) : data{val} {}$/;"	f	struct:Linked_node
Linked_node	.\node.h	/^struct Linked_node {$/;"	s
Min_stack	.\stupidstack.h	/^class Min_stack {$/;"	c
PREMIUM	.\stupidoop.h	/^	REGULAR, PREMIUM, ADMIN, SUPERADMIN$/;"	m	class:User_type
Product_manager	.\stupidoop.h	/^	Product_manager(const std::string& n, size_t i) : Employee{n,i}, num_calls{0} {}$/;"	f	class:Product_manager
Product_manager	.\stupidoop.h	/^class Product_manager : public Employee {$/;"	c
Queue	.\stupidqueue.h	/^	Queue() : front {nullptr}, back {nullptr} {}$/;"	f	class:Queue
Queue	.\stupidqueue.h	/^	Queue(Linked_node* n) : front {n}, back {front} {}$/;"	f	class:Queue
Queue	.\stupidqueue.h	/^	Queue(int d) : front {new Linked_node {d}}, back {front} {}$/;"	f	class:Queue
Queue	.\stupidqueue.h	/^class Queue {$/;"	c
REGULAR	.\stupidoop.h	/^	REGULAR, PREMIUM, ADMIN, SUPERADMIN$/;"	m	class:User_type
Response	.\stupidoop.h	/^class Response {}; class Call {};$/;"	c
SPADES	.\stupidoop.h	/^	HEARTS, SPADES, DIAMONDS, CLUBS$/;"	m	class:Suit
Stack	.\stupidstack.h	/^	Stack() : tp {nullptr} {}$/;"	f	class:Stack
Stack	.\stupidstack.h	/^	Stack(N* n) : tp {n} {}$/;"	f	class:Stack
Stack	.\stupidstack.h	/^	Stack(T top_data) : tp {new N {top_data}} {}$/;"	f	class:Stack
Stack	.\stupidstack.h	/^class Stack {$/;"	c
Stack_queue	.\stupidqueue.h	/^	Stack_queue() {}$/;"	f	class:Stack_queue
Stack_queue	.\stupidqueue.h	/^class Stack_queue {$/;"	c
Stack_set	.\stupidstack.h	/^	Stack_set(size_t mh) : ss{std::stack<T>{}}, max_height {mh} {}$/;"	f	class:Stack_set
Stack_set	.\stupidstack.h	/^class Stack_set {$/;"	c
Static_graph	.\stupidgraph.h	/^	explicit Static_graph(size_t num_vertices) : adj(num_vertices) {}$/;"	f	class:Static_graph
Static_graph	.\stupidgraph.h	/^class Static_graph {$/;"	c
Static_vertex_property	.\stupidgraph.h	/^	Static_vertex_property() : parent{no_parent}, status{DFS::UNEXPLORED} {}$/;"	f	struct:Static_vertex_property
Static_vertex_property	.\stupidgraph.h	/^	Static_vertex_property(int p) : parent{p}, status{DFS::UNEXPLORED} {}$/;"	f	struct:Static_vertex_property
Static_vertex_property	.\stupidgraph.h	/^struct Static_vertex_property {$/;"	s
Suit	.\stupidoop.h	/^enum class Suit : char {$/;"	c
Tech_lead	.\stupidoop.h	/^	Tech_lead(const std::string& n, size_t i) : Employee{n,i} {}$/;"	f	class:Tech_lead
Tech_lead	.\stupidoop.h	/^class Tech_lead : public Employee {$/;"	c
UNEXPLORED	.\stupidgraph.h	/^	UNEXPLORED = 0, EXPLORING, EXPLORED$/;"	m	class:DFS
User	.\stupidoop.h	/^	User() : id{invalid} {};$/;"	f	class:User
User	.\stupidoop.h	/^	User(const std::string& n, long long i, User_type t = User_type::REGULAR) :$/;"	f	class:User
User	.\stupidoop.h	/^class User {$/;"	c
User_type	.\stupidoop.h	/^enum class User_type : char {$/;"	c
V_iter	.\stupidgraph.h	/^	struct V_iter {$/;"	s	class:Static_graph
add_balance	.\stupidoop.h	/^	void add_balance(double addition) {balance += addition;}$/;"	f	class:User
add_book	.\stupidoop.h	/^	static void add_book(Book&& book) {books()[book.get_id()] = std::move(book);}$/;"	f	class:Book
add_book	.\stupidoop.h	/^	static void add_book(const Book& book) {books()[book.get_id()] = book;}$/;"	f	class:Book
add_book	.\stupidoop.h	/^	static void add_book(long long i, double p, std::string&& c) {$/;"	f	class:Book
add_book	.\stupidoop.h	/^	void add_book(const Book& book) {Book::add_book(book);}$/;"	f	class:Library
add_edge	.\stupidgraph.h	/^	void add_edge(size_t source, size_t dest, int weight = 1) {$/;"	f	class:Static_graph
add_fresher	.\stupidoop.h	/^	void add_fresher(const std::string& name, size_t id) {$/;"	f	class:Callcenter
add_list	.\stupidlist.cpp	/^Node* add_list(Node* head1, Node* head2) {$/;"	f
add_node	.\stupidgraph.h	/^	size_t add_node() {$/;"	f	class:Static_graph
add_rev_list	.\stupidlist.cpp	/^Node* add_rev_list(Node* head1, Node* head2) {$/;"	f
add_rev_list_rec	.\stupidlist.cpp	/^Node* add_rev_list_rec(Node* head1, Node* head2, int& carry) {$/;"	f
add_user	.\stupidoop.h	/^	static void add_user(User&& user) {users()[user.get_id()] = std::move(user);}	$/;"	f	class:User
add_user	.\stupidoop.h	/^	static void add_user(const User& user) {users()[user.get_id()] = user;}$/;"	f	class:User
add_user	.\stupidoop.h	/^	static void add_user(const std::string& n, long long i, User_type t = User_type::REGULAR) {$/;"	f	class:User
add_user	.\stupidoop.h	/^	void add_user(const User& user) {User::add_user(user);}$/;"	f	class:Library
adjust_price	.\stupidoop.h	/^	void adjust_price(double new_price) {price = new_price;}$/;"	f	class:Book
append	.\node.h	/^	Linked_node* append(value_type val) {$/;"	f	struct:Linked_node
available_freshers	.\stupidoop.h	/^	std::queue<Fresher> available_freshers;$/;"	m	class:Callcenter
available_handlers	.\stupidoop.h	/^	size_t available_handlers() const {$/;"	f	class:Callcenter
b	.\stupidoop.h	/^	Book b;$/;"	m	class:Library
back	.\stupidqueue.h	/^	Linked_node *front, *back;$/;"	m	class:Queue
balance	.\stupidoop.h	/^	double balance;$/;"	m	class:User
begin	.\stupidgraph.h	/^		Adj_iter<iterator> begin() {return {vertex->begin()};}$/;"	f	struct:Static_graph::V_iter
begin	.\stupidgraph.h	/^	adjacent_iterator begin(size_t vertex) {return {adj[vertex].begin()};}$/;"	f	class:Static_graph
begin	.\stupidgraph.h	/^	const_adjacent_iterator begin(size_t vertex) const {return {adj[vertex].begin()};}$/;"	f	class:Static_graph
begin	.\stupidgraph.h	/^	iterator begin() {return {adj.begin()};}$/;"	f	class:Static_graph
bitops_to_convert	.\stupidbits.h	/^int bitops_to_convert(int a, int b) {$/;"	f
books	.\stupidoop.h	/^	static Book_map& books() {$/;"	f	class:Book
busy	.\stupidoop.h	/^	bool busy;$/;"	m	class:Employee
busy_freshers	.\stupidoop.h	/^	std::unordered_map<size_t,Fresher> busy_freshers;	\/\/ storage necessary since reference is returned$/;"	m	class:Callcenter
buy_book	.\stupidoop.h	/^	bool buy_book(size_t book_id) {$/;"	f	class:User
charset_size	.\anastr.cpp	/^constexpr size_t charset_size(char c) {return 256;}$/;"	f
charset_size	.\dupbegone.cpp	/^constexpr size_t charset_size(char c) {return 256;}$/;"	f
clear_bit	.\stupidbits.h	/^T clear_bit(const T& num, size_t n) {$/;"	f
clear_busy	.\stupidoop.h	/^	void clear_busy() 	{busy = false;}$/;"	f	class:Employee
content	.\stupidoop.h	/^	std::string content;$/;"	m	class:Book
count_books	.\stupidoop.h	/^	static size_t count_books() const {$/;"	f	class:Book
count_users	.\stupidoop.h	/^	static size_t count_users() const {$/;"	f	class:User
data	.\node.h	/^	int data;$/;"	m	struct:Binary_node
data	.\node.h	/^	int data;$/;"	m	struct:Linked_node
dec_to_bin	.\stupidbits.h	/^std::string dec_to_bin(const std::string& num) {$/;"	f
delete_node	.\stupidlist.cpp	/^Node* delete_node(Node* head, Node* to_del) {$/;"	f
deq	.\stupidqueue.h	/^	std::stack<int> enq, deq;$/;"	m	class:Stack_queue
dequeue	.\stupidqueue.h	/^	Linked_node* dequeue() {$/;"	f	class:Queue
dequeue	.\stupidqueue.h	/^	int dequeue() {$/;"	f	class:Stack_queue
dest	.\stupidgraph.h	/^		int dest;	\/\/ index of destination vertex$/;"	m	struct:Static_graph::Edge
dfs	.\stupidgraph.h	/^Static_property_map dfs(const Static_graph& g, int s) {$/;"	f
dumpto_deq	.\stupidqueue.h	/^	void dumpto_deq() {$/;"	f	class:Stack_queue
dumpto_enq	.\stupidqueue.h	/^	void dumpto_enq() {$/;"	f	class:Stack_queue
dup_rem	.\dupbegone.cpp	/^string& dup_rem(string& str) {$/;"	f
dup_rem_c	.\dupbegone.cpp	/^char* dup_rem_c(char* str) {$/;"	f
edge_number	.\stupidgraph.h	/^	size_t edge_number() const {$/;"	f	class:Static_graph
emplace_book	.\stupidoop.h	/^	void emplace_book(Args... args) {Book::add_book(Book{args...});}$/;"	f	class:Library
emplace_user	.\stupidoop.h	/^	void emplace_user(Args... args) {User::add_user(User{args...});}$/;"	f	class:Library
empty	.\stupidgraph.h	/^	bool empty() const 				{return adj.empty();}$/;"	f	class:Static_graph
empty	.\stupidqueue.h	/^	bool empty() {$/;"	f	class:Stack_queue
empty	.\stupidstack.h	/^	bool empty() {$/;"	f	class:Stack_set
end	.\stupidgraph.h	/^		Adj_iter<iterator> end() {return {vertex->end()};}$/;"	f	struct:Static_graph::V_iter
end	.\stupidgraph.h	/^	adjacent_iterator end(size_t vertex) {return {adj[vertex].end()};}$/;"	f	class:Static_graph
end	.\stupidgraph.h	/^	const_adjacent_iterator end(size_t vertex)   const {return {adj[vertex].end()};}$/;"	f	class:Static_graph
end	.\stupidgraph.h	/^	iterator end() {return {adj.end()};}$/;"	f	class:Static_graph
enq	.\stupidqueue.h	/^	std::stack<int> enq, deq;$/;"	m	class:Stack_queue
enqueue	.\stupidqueue.h	/^	void enqueue(Linked_node* latest) {$/;"	f	class:Queue
enqueue	.\stupidqueue.h	/^	void enqueue(int val) {$/;"	f	class:Stack_queue
even_mask	.\stupidbits.h	/^constexpr int even_mask = 0x5555;	\/\/ 0101 0101 0101 0101$/;"	v
examine	.\stupidqueue.h	/^	void examine() {$/;"	f	class:Stack_queue
examine	.\stupidstack.h	/^	void examine() {$/;"	f	class:Hanoi_towers
find	.\stupidgraph.h	/^	N* find(int data) {$/;"	f	class:BST
find	.\stupidoop.h	/^	static Book find(size_t id) {$/;"	f	class:Book
find	.\stupidoop.h	/^	static User find(size_t user_id) {$/;"	f	class:User
find_book	.\stupidoop.h	/^	Book find_book(size_t id) const {return Book::find(id);}$/;"	f	class:Library
find_loop_start	.\stupidlist.cpp	/^Node* find_loop_start(Node* head) {$/;"	f
find_missing	.\stupidbits.h	/^bigint find_missing(std::vector<bigint> nums) { 	\/\/ pass by copy as it will be locally used$/;"	f
find_nth_last	.\stupidlist.cpp	/^Node* find_nth_last (Node* head, size_t n) {$/;"	f
find_user	.\stupidoop.h	/^	User find_user(size_t id) const {return User::find(id);}$/;"	f	class:Library
finish_call	.\stupidoop.h	/^	void finish_call() {$/;"	f	class:Product_manager
finish_call	.\stupidoop.h	/^void Fresher::finish_call() {$/;"	f	class:Fresher
first_common_ancestor	.\stupidgraph.h	/^Node* first_common_ancestor(Node* root, Node* a, Node* b) {$/;"	f
fresher_finished	.\stupidoop.h	/^	void fresher_finished(Fresher& fresher) {$/;"	f	class:Callcenter
front	.\stupidqueue.h	/^	Linked_node *front, *back;$/;"	m	class:Queue
game_size	.\stupidstack.h	/^	size_t game_size;$/;"	m	class:Hanoi_towers
get_balance	.\stupidoop.h	/^	double get_balance() const 	{return balance;}$/;"	f	class:User
get_book	.\stupidoop.h	/^	Book get_book(size_t book_id) const {$/;"	f	class:User
get_call_handler	.\stupidoop.h	/^	Call_handler& get_call_handler() {$/;"	f	class:Callcenter
get_id	.\stupidoop.h	/^	long long get_id() const 	{return id;}$/;"	f	class:User
get_id	.\stupidoop.h	/^	long long get_id() const {return id;}$/;"	f	class:Book
get_id	.\stupidoop.h	/^	size_t get_id() const {return id;}$/;"	f	class:Employee
get_price	.\stupidoop.h	/^	double get_price() const {return price;}$/;"	f	class:Book
get_root	.\stupidgraph.h	/^	N* get_root() {return root;}$/;"	f	class:BST
get_suit	.\stupidoop.h	/^	Suit get_suit() {return suit;}$/;"	f	class:Card
get_val	.\stupidoop.h	/^	virtual int get_val() {return val;}$/;"	f	class:Card
id	.\stupidoop.h	/^	long long id;	$/;"	m	class:User
id	.\stupidoop.h	/^	long long id;$/;"	m	class:Book
id	.\stupidoop.h	/^	size_t id;$/;"	m	class:Employee
init_head	.\stupidlist.cpp	/^Node* init_head() {$/;"	f
inorder_walk	.\stupidgraph.h	/^void inorder_walk(Nd* root, Op op) {$/;"	f
insert	.\node.h	/^	Linked_node* insert(value_type val) {$/;"	f	struct:Linked_node
insert	.\stupidgraph.h	/^	void insert(int data) {$/;"	f	class:BST
invalid	.\stupidoop.h	/^constexpr long long invalid = -1;$/;"	v
is_anagram	.\anastr.cpp	/^bool is_anagram(const string& a, const string& b) {$/;"	f
is_balanced	.\stupidgraph.h	/^bool is_balanced(const N* root) {$/;"	f
is_busy	.\stupidoop.h	/^	bool is_busy()  const {return busy;}$/;"	f	class:Employee
is_left_child	.\stupidgraph.h	/^bool is_left_child(Node* node) {$/;"	f
is_subtree	.\stupidgraph.h	/^bool is_subtree(Node* tree, Node* subtree) {$/;"	f
layer_nodes	.\stupidgraph.h	/^Layers layer_nodes(N* root) {$/;"	f
layer_nodes_iter	.\stupidgraph.h	/^Layers layer_nodes_iter(N* root) {$/;"	f
layer_nodes_recurse	.\stupidgraph.h	/^void layer_nodes_recurse(N* root, size_t layer, Layers& layers) {$/;"	f
listen_request	.\stupidoop.h	/^	void listen_request() {}	\/\/ listen to user requests (web server)$/;"	f	class:Library
main	.\anastr.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\dupbegone.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\revstr.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\str_encode_space.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\stupidlist.cpp	/^int main() {$/;"	f
main	.\tester.cpp	/^int main() {$/;"	f
max_height	.\stupidgraph.h	/^int max_height(const N* root) {$/;"	f
max_height	.\stupidstack.h	/^	size_t max_height;$/;"	m	class:Stack_set
min	.\stupidstack.h	/^	const Linked_node* min() {$/;"	f	class:Min_stack
min_height	.\stupidgraph.h	/^int min_height(const N* root) {$/;"	f
mins	.\stupidstack.h	/^	Stack<Linked_node> mins;$/;"	m	class:Min_stack
move	.\stupidstack.h	/^	void move(size_t move_from, size_t move_to, size_t num_moved) {$/;"	f	class:Hanoi_towers
moves_taken	.\stupidstack.h	/^	size_t moves_taken;$/;"	m	class:Hanoi_towers
name	.\stupidoop.h	/^	std::string name;$/;"	m	class:Employee
name	.\stupidoop.h	/^	std::string name;$/;"	m	class:User
neighbour_values	.\stupidbits.h	/^std::pair<T,T> neighbour_values(const T& num) {$/;"	f
no_parent	.\stupidgraph.h	/^constexpr int no_parent = -1;$/;"	v
none	.\stupidbits.h	/^constexpr int none = -1;$/;"	v
num_books	.\stupidoop.h	/^	size_t num_books() const {return Book::count_books();}$/;"	f	class:Library
num_calls	.\stupidoop.h	/^	int num_calls;$/;"	m	class:Product_manager
num_users	.\stupidoop.h	/^	size_t num_users() const {return User::count_users();}$/;"	f	class:Library
odd_mask	.\stupidbits.h	/^constexpr int odd_mask 	= 0xAAAA;	\/\/ 1010 1010 1010 1010$/;"	v
operator !=	.\stupidgraph.h	/^		bool operator!=(const_reference other) {return other.edge != edge;}$/;"	f	struct:Static_graph::Adj_iter
operator !=	.\stupidgraph.h	/^		bool operator!=(const_reference other) {return other.vertex != vertex;}$/;"	f	struct:Static_graph::V_iter
operator ()	.\stupidoop.h	/^	size_t operator()(const E& e) const {$/;"	f	struct:Id_hash
operator *	.\node.h	/^	value_type operator*() {return data;}$/;"	f	struct:Linked_node
operator *	.\stupidgraph.h	/^		Iter operator*() {return vertex;}$/;"	f	struct:Static_graph::V_iter
operator *	.\stupidgraph.h	/^		int operator*() {return edge->dest;}$/;"	f	struct:Static_graph::Adj_iter
operator +	.\stupidgraph.h	/^		size_t operator+(const_reference other) {return other.vertex + vertex;}$/;"	f	struct:Static_graph::V_iter
operator ++	.\stupidgraph.h	/^		reference operator++() {++edge; return *this;}$/;"	f	struct:Static_graph::Adj_iter
operator ++	.\stupidgraph.h	/^		reference operator++() {++vertex; return *this;}$/;"	f	struct:Static_graph::V_iter
operator -	.\stupidgraph.h	/^		size_t operator-(const_reference other) {return vertex - other.vertex;}$/;"	f	struct:Static_graph::V_iter
operator --	.\stupidgraph.h	/^		reference operator--() {--edge; return *this;}$/;"	f	struct:Static_graph::Adj_iter
operator --	.\stupidgraph.h	/^		reference operator--() {--vertex; return *this;}$/;"	f	struct:Static_graph::V_iter
operator <<	.\node.h	/^std::ostream& operator<<(std::ostream& os, const Linked_node* n) {$/;"	f
operator <<	.\stupidlist.cpp	/^std::ostream& operator<<(std::ostream& os, Node* head) {$/;"	f
operator ==	.\stupidgraph.h	/^		bool operator==(const_reference other) {return other.edge == edge;}$/;"	f	struct:Static_graph::Adj_iter
operator ==	.\stupidgraph.h	/^		bool operator==(const_reference other) {return other.vertex == vertex;}$/;"	f	struct:Static_graph::V_iter
operator ==	.\stupidoop.h	/^	bool operator==(const Employee& other) const {return other.id == id;} \/\/ identity and hash$/;"	f	class:Employee
operator bool	.\stupidoop.h	/^	explicit operator bool() const {return id != invalid;}$/;"	f	class:Book
operator bool	.\stupidoop.h	/^	explicit operator bool() const {return id != invalid;}$/;"	f	class:User
override	.\stupidoop.h	/^	void finish_call() override;$/;"	m	class:Fresher
owned_books	.\stupidoop.h	/^	std::unordered_set<size_t> owned_books;$/;"	m	class:User
parent	.\stupidgraph.h	/^	int parent;	\/\/ index, = no_parent if no parent$/;"	m	struct:Static_vertex_property
peek	.\stupidqueue.h	/^	int peek() {$/;"	f	class:Stack_queue
pop	.\stupidstack.h	/^	Linked_node* pop() {$/;"	f	class:Min_stack
pop	.\stupidstack.h	/^	N* pop() {$/;"	f	class:Stack
pop	.\stupidstack.h	/^	T pop() {$/;"	f	class:Stack_set
pop_at	.\stupidstack.h	/^	T pop_at(size_t si) {$/;"	f	class:Stack_set
price	.\stupidoop.h	/^	double price;$/;"	m	class:Book
print	.\stupidgraph.h	/^	void print() const {$/;"	f	class:BST
print	.\stupidgraph.h	/^	void print() {$/;"	f	class:Static_graph
print	.\stupidstack.h	/^	void print() {$/;"	f	class:Stack_set
print_layers	.\stupidgraph.h	/^void print_layers(const Layers& layers) {$/;"	f
product_manager	.\stupidoop.h	/^	Product_manager product_manager;$/;"	m	class:Callcenter
push	.\stupidstack.h	/^	N* push(N* n) {$/;"	f	class:Stack
push	.\stupidstack.h	/^	N* push(T data) {$/;"	f	class:Stack
push	.\stupidstack.h	/^	size_t push(const T& val) {$/;"	f	class:Stack_set
push	.\stupidstack.h	/^	void push(Linked_node* n) {$/;"	f	class:Min_stack
push	.\stupidstack.h	/^	void push(T d) {return push(new Linked_node {d});}$/;"	f	class:Min_stack
read	.\stupidoop.h	/^	std::pair<std::string, size_t> read(size_t start_index, size_t chars_to_read) {$/;"	f	class:Book
rem_dup	.\stupidlist.cpp	/^Node* rem_dup(Node* head) {$/;"	f
rem_dup_nobuf	.\stupidlist.cpp	/^Node* rem_dup_nobuf(Node* head) {$/;"	f
remove_book	.\stupidoop.h	/^	static void remove_book(size_t book_id) {$/;"	f	class:Book
remove_user	.\stupidoop.h	/^	static void remove_user(size_t user_id) {$/;"	f	class:User
rev_str	.\revstr.cpp	/^char* rev_str(char* str) {$/;"	f
root	.\stupidgraph.h	/^	N* root;$/;"	m	class:BST
set_bit	.\stupidbits.h	/^T set_bit(const T& num, size_t n) {$/;"	f
set_busy	.\stupidoop.h	/^	void set_busy() 	{busy = true;}$/;"	f	class:Employee
size	.\stupidgraph.h	/^	size_t size() const 			{return adj.size();}$/;"	f	class:Static_graph
solve	.\stupidstack.h	/^	size_t solve() {$/;"	f	class:Hanoi_towers
ss	.\stupidstack.h	/^	std::vector<std::stack<T>> ss;$/;"	m	class:Stack_set
status	.\stupidgraph.h	/^	DFS status;$/;"	m	struct:Static_vertex_property
str_encode_space	.\str_encode_space.cpp	/^const string& str_encode_space(string& str) {$/;"	f
substitute_bits	.\stupidbits.h	/^b32 substitute_bits(b32 N, b32 M, size_t i, size_t j) {$/;"	f
suit	.\stupidoop.h	/^	Suit suit;$/;"	m	class:Card
sum_print	.\stupidgraph.h	/^void sum_print(Node* root, int sum_tot, int sum_left) {$/;"	f
sum_tree	.\stupidgraph.h	/^bool sum_tree(Node* root, int sum_tot) {$/;"	f
sum_tree	.\stupidgraph.h	/^bool sum_tree(Node* root, int sum_tot, int sum_left) {$/;"	f
sum_tree_all	.\stupidgraph.h	/^void sum_tree_all(Node* root, int sum_tot) {$/;"	f
swap_parity_bits	.\stupidbits.h	/^int swap_parity_bits(int num) {$/;"	f
take_call	.\stupidoop.h	/^	int take_call() {$/;"	f	class:Product_manager
tech_lead	.\stupidoop.h	/^	Tech_lead tech_lead;$/;"	m	class:Callcenter
test_add	.\stupidlist.cpp	/^void test_add() {$/;"	f
test_binary_search_tree	.\stupidgraph.h	/^void test_binary_search_tree() {$/;"	f
test_bitops_to_convert	.\stupidbits.h	/^void test_bitops_to_convert() {$/;"	f
test_callcenter	.\stupidoop.h	/^void test_callcenter() {$/;"	f
test_cards	.\stupidoop.h	/^void test_cards() {$/;"	f
test_dec_to_bin	.\stupidbits.h	/^void test_dec_to_bin() {$/;"	f
test_delete	.\stupidlist.cpp	/^void test_delete() {$/;"	f
test_find_missing	.\stupidbits.h	/^void test_find_missing() {$/;"	f
test_first_common_ancestor	.\stupidgraph.h	/^void test_first_common_ancestor() {$/;"	f
test_hanoi	.\stupidstack.h	/^void test_hanoi() {$/;"	f
test_layer_nodes	.\stupidgraph.h	/^void test_layer_nodes() {$/;"	f
test_library	.\stupidoop.h	/^void test_library() {$/;"	f
test_loop	.\stupidlist.cpp	/^void test_loop() {$/;"	f
test_min_stack	.\stupidstack.h	/^void test_min_stack() {$/;"	f
test_neighbour_values	.\stupidbits.h	/^void test_neighbour_values() {$/;"	f
test_nth	.\stupidlist.cpp	/^void test_nth() {$/;"	f
test_stack_queue	.\stupidqueue.h	/^void test_stack_queue() {$/;"	f
test_stack_set	.\stupidstack.h	/^void test_stack_set() {$/;"	f
test_static_graph	.\stupidgraph.h	/^void test_static_graph() {$/;"	f
test_sum_tree	.\stupidgraph.h	/^void test_sum_tree() {$/;"	f
test_swap_parity_bits	.\stupidbits.h	/^void test_swap_parity_bits() {$/;"	f
top	.\stupidstack.h	/^	const N* top() {return tp;}$/;"	f	class:Stack
towers	.\stupidstack.h	/^	std::vector<std::stack<int>> towers;$/;"	m	class:Hanoi_towers
tree_find	.\stupidgraph.h	/^	N** tree_find(N** start, int key) {$/;"	f	class:BST
tree_min	.\stupidgraph.h	/^Node* tree_min(Node* node) {$/;"	f
tree_successor	.\stupidgraph.h	/^Node* tree_successor(Node* node) {$/;"	f
type	.\stupidoop.h	/^	User_type type;$/;"	m	class:User
u	.\stupidoop.h	/^	User u;$/;"	m	class:Library
users	.\stupidoop.h	/^	static User_map& users() {$/;"	f	class:User
val	.\stupidoop.h	/^	int val;$/;"	m	class:Card
vertex_number	.\stupidgraph.h	/^	size_t vertex_number() const 	{return adj.size();}$/;"	f	class:Static_graph
weight	.\stupidgraph.h	/^		int weight() {return edge->weight;}$/;"	f	struct:Static_graph::Adj_iter
weight	.\stupidgraph.h	/^		int weight;$/;"	m	struct:Static_graph::Edge
workplace	.\stupidoop.h	/^	Callcenter* workplace;	\/\/ need to be added back onto available queue after finishing call$/;"	m	class:Fresher

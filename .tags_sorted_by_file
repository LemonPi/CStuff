charset_size	anastr.cpp	/^constexpr size_t charset_size(char c) {return 256;}$/;"	f
is_anagram	anastr.cpp	/^bool is_anagram(const string& a, const string& b) {$/;"	f
main	anastr.cpp	/^int main(int argc, char** argv) {$/;"	f
charset_size	dupbegone.cpp	/^constexpr size_t charset_size(char c) {return 256;}$/;"	f
dup_rem	dupbegone.cpp	/^string& dup_rem(string& str) {$/;"	f
dup_rem_c	dupbegone.cpp	/^char* dup_rem_c(char* str) {$/;"	f
main	dupbegone.cpp	/^int main(int argc, char** argv) {$/;"	f
Binary_node	node.h	/^	Binary_node(int d) : data{d} {}$/;"	f	struct:Binary_node
Binary_node	node.h	/^struct Binary_node {$/;"	s
Linked_node	node.h	/^	Linked_node(value_type val) : data{val} {}$/;"	f	struct:Linked_node
Linked_node	node.h	/^struct Linked_node {$/;"	s
append	node.h	/^	Linked_node* append(value_type val) {$/;"	f	struct:Linked_node
data	node.h	/^	int data;$/;"	m	struct:Binary_node
data	node.h	/^	int data;$/;"	m	struct:Linked_node
insert	node.h	/^	Linked_node* insert(value_type val) {$/;"	f	struct:Linked_node
operator *	node.h	/^	value_type operator*() {return data;}$/;"	f	struct:Linked_node
operator <<	node.h	/^std::ostream& operator<<(std::ostream& os, const Linked_node* n) {$/;"	f
main	revstr.cpp	/^int main(int argc, char** argv) {$/;"	f
rev_str	revstr.cpp	/^char* rev_str(char* str) {$/;"	f
main	str_encode_space.cpp	/^int main(int argc, char** argv) {$/;"	f
str_encode_space	str_encode_space.cpp	/^const string& str_encode_space(string& str) {$/;"	f
GETINPUT	stupidbits.h	8;"	d
bitops_to_convert	stupidbits.h	/^int bitops_to_convert(int a, int b) {$/;"	f
clear_bit	stupidbits.h	/^T clear_bit(const T& num, size_t n) {$/;"	f
dec_to_bin	stupidbits.h	/^std::string dec_to_bin(const std::string& num) {$/;"	f
even_mask	stupidbits.h	/^constexpr int even_mask = 0x5555;	\/\/ 0101 0101 0101 0101$/;"	v
find_missing	stupidbits.h	/^bigint find_missing(std::vector<bigint> nums) { 	\/\/ pass by copy as it will be locally used$/;"	f
neighbour_values	stupidbits.h	/^std::pair<T,T> neighbour_values(const T& num) {$/;"	f
none	stupidbits.h	/^constexpr int none = -1;$/;"	v
odd_mask	stupidbits.h	/^constexpr int odd_mask 	= 0xAAAA;	\/\/ 1010 1010 1010 1010$/;"	v
set_bit	stupidbits.h	/^T set_bit(const T& num, size_t n) {$/;"	f
substitute_bits	stupidbits.h	/^b32 substitute_bits(b32 N, b32 M, size_t i, size_t j) {$/;"	f
swap_parity_bits	stupidbits.h	/^int swap_parity_bits(int num) {$/;"	f
test_bitops_to_convert	stupidbits.h	/^void test_bitops_to_convert() {$/;"	f
test_dec_to_bin	stupidbits.h	/^void test_dec_to_bin() {$/;"	f
test_find_missing	stupidbits.h	/^void test_find_missing() {$/;"	f
test_neighbour_values	stupidbits.h	/^void test_neighbour_values() {$/;"	f
test_swap_parity_bits	stupidbits.h	/^void test_swap_parity_bits() {$/;"	f
Adj_iter	stupidgraph.h	/^	struct Adj_iter {$/;"	s	class:Static_graph
BST	stupidgraph.h	/^	BST() : root{nullptr} {};$/;"	f	class:BST
BST	stupidgraph.h	/^class BST {$/;"	c
DFS	stupidgraph.h	/^enum class DFS : char {$/;"	c
EXPLORING	stupidgraph.h	/^	UNEXPLORED = 0, EXPLORING, EXPLORED$/;"	m	class:DFS
Edge	stupidgraph.h	/^		Edge(int d, int w) : dest{d}, weight{w} {}$/;"	f	struct:Static_graph::Edge
Edge	stupidgraph.h	/^	struct Edge {$/;"	s	class:Static_graph
Static_graph	stupidgraph.h	/^	explicit Static_graph(size_t num_vertices) : adj(num_vertices) {}$/;"	f	class:Static_graph
Static_graph	stupidgraph.h	/^class Static_graph {$/;"	c
Static_vertex_property	stupidgraph.h	/^	Static_vertex_property() : parent{no_parent}, status{DFS::UNEXPLORED} {}$/;"	f	struct:Static_vertex_property
Static_vertex_property	stupidgraph.h	/^	Static_vertex_property(int p) : parent{p}, status{DFS::UNEXPLORED} {}$/;"	f	struct:Static_vertex_property
Static_vertex_property	stupidgraph.h	/^struct Static_vertex_property {$/;"	s
UNEXPLORED	stupidgraph.h	/^	UNEXPLORED = 0, EXPLORING, EXPLORED$/;"	m	class:DFS
V_iter	stupidgraph.h	/^	struct V_iter {$/;"	s	class:Static_graph
add_edge	stupidgraph.h	/^	void add_edge(size_t source, size_t dest, int weight = 1) {$/;"	f	class:Static_graph
add_node	stupidgraph.h	/^	size_t add_node() {$/;"	f	class:Static_graph
begin	stupidgraph.h	/^		Adj_iter<iterator> begin() {return {vertex->begin()};}$/;"	f	struct:Static_graph::V_iter
begin	stupidgraph.h	/^	adjacent_iterator begin(size_t vertex) {return {adj[vertex].begin()};}$/;"	f	class:Static_graph
begin	stupidgraph.h	/^	const_adjacent_iterator begin(size_t vertex) const {return {adj[vertex].begin()};}$/;"	f	class:Static_graph
begin	stupidgraph.h	/^	iterator begin() {return {adj.begin()};}$/;"	f	class:Static_graph
dest	stupidgraph.h	/^		int dest;	\/\/ index of destination vertex$/;"	m	struct:Static_graph::Edge
dfs	stupidgraph.h	/^Static_property_map dfs(const Static_graph& g, int s) {$/;"	f
edge_number	stupidgraph.h	/^	size_t edge_number() const {$/;"	f	class:Static_graph
empty	stupidgraph.h	/^	bool empty() const 				{return adj.empty();}$/;"	f	class:Static_graph
end	stupidgraph.h	/^		Adj_iter<iterator> end() {return {vertex->end()};}$/;"	f	struct:Static_graph::V_iter
end	stupidgraph.h	/^	adjacent_iterator end(size_t vertex) {return {adj[vertex].end()};}$/;"	f	class:Static_graph
end	stupidgraph.h	/^	const_adjacent_iterator end(size_t vertex)   const {return {adj[vertex].end()};}$/;"	f	class:Static_graph
end	stupidgraph.h	/^	iterator end() {return {adj.end()};}$/;"	f	class:Static_graph
find	stupidgraph.h	/^	N* find(int data) {$/;"	f	class:BST
first_common_ancestor	stupidgraph.h	/^Node* first_common_ancestor(Node* root, Node* a, Node* b) {$/;"	f
get_root	stupidgraph.h	/^	N* get_root() {return root;}$/;"	f	class:BST
inorder_walk	stupidgraph.h	/^void inorder_walk(Nd* root, Op op) {$/;"	f
insert	stupidgraph.h	/^	void insert(int data) {$/;"	f	class:BST
is_balanced	stupidgraph.h	/^bool is_balanced(const N* root) {$/;"	f
is_left_child	stupidgraph.h	/^bool is_left_child(Node* node) {$/;"	f
is_subtree	stupidgraph.h	/^bool is_subtree(Node* tree, Node* subtree) {$/;"	f
layer_nodes	stupidgraph.h	/^Layers layer_nodes(N* root) {$/;"	f
layer_nodes_iter	stupidgraph.h	/^Layers layer_nodes_iter(N* root) {$/;"	f
layer_nodes_recurse	stupidgraph.h	/^void layer_nodes_recurse(N* root, size_t layer, Layers& layers) {$/;"	f
max_height	stupidgraph.h	/^int max_height(const N* root) {$/;"	f
min_height	stupidgraph.h	/^int min_height(const N* root) {$/;"	f
no_parent	stupidgraph.h	/^constexpr int no_parent = -1;$/;"	v
operator !=	stupidgraph.h	/^		bool operator!=(const_reference other) {return other.edge != edge;}$/;"	f	struct:Static_graph::Adj_iter
operator !=	stupidgraph.h	/^		bool operator!=(const_reference other) {return other.vertex != vertex;}$/;"	f	struct:Static_graph::V_iter
operator *	stupidgraph.h	/^		Iter operator*() {return vertex;}$/;"	f	struct:Static_graph::V_iter
operator *	stupidgraph.h	/^		int operator*() {return edge->dest;}$/;"	f	struct:Static_graph::Adj_iter
operator +	stupidgraph.h	/^		size_t operator+(const_reference other) {return other.vertex + vertex;}$/;"	f	struct:Static_graph::V_iter
operator ++	stupidgraph.h	/^		reference operator++() {++edge; return *this;}$/;"	f	struct:Static_graph::Adj_iter
operator ++	stupidgraph.h	/^		reference operator++() {++vertex; return *this;}$/;"	f	struct:Static_graph::V_iter
operator -	stupidgraph.h	/^		size_t operator-(const_reference other) {return vertex - other.vertex;}$/;"	f	struct:Static_graph::V_iter
operator --	stupidgraph.h	/^		reference operator--() {--edge; return *this;}$/;"	f	struct:Static_graph::Adj_iter
operator --	stupidgraph.h	/^		reference operator--() {--vertex; return *this;}$/;"	f	struct:Static_graph::V_iter
operator ==	stupidgraph.h	/^		bool operator==(const_reference other) {return other.edge == edge;}$/;"	f	struct:Static_graph::Adj_iter
operator ==	stupidgraph.h	/^		bool operator==(const_reference other) {return other.vertex == vertex;}$/;"	f	struct:Static_graph::V_iter
parent	stupidgraph.h	/^	int parent;	\/\/ index, = no_parent if no parent$/;"	m	struct:Static_vertex_property
print	stupidgraph.h	/^	void print() const {$/;"	f	class:BST
print	stupidgraph.h	/^	void print() {$/;"	f	class:Static_graph
print_layers	stupidgraph.h	/^void print_layers(const Layers& layers) {$/;"	f
root	stupidgraph.h	/^	N* root;$/;"	m	class:BST
size	stupidgraph.h	/^	size_t size() const 			{return adj.size();}$/;"	f	class:Static_graph
status	stupidgraph.h	/^	DFS status;$/;"	m	struct:Static_vertex_property
sum_print	stupidgraph.h	/^void sum_print(Node* root, int sum_tot, int sum_left) {$/;"	f
sum_tree	stupidgraph.h	/^bool sum_tree(Node* root, int sum_tot) {$/;"	f
sum_tree	stupidgraph.h	/^bool sum_tree(Node* root, int sum_tot, int sum_left) {$/;"	f
sum_tree_all	stupidgraph.h	/^void sum_tree_all(Node* root, int sum_tot) {$/;"	f
test_binary_search_tree	stupidgraph.h	/^void test_binary_search_tree() {$/;"	f
test_first_common_ancestor	stupidgraph.h	/^void test_first_common_ancestor() {$/;"	f
test_layer_nodes	stupidgraph.h	/^void test_layer_nodes() {$/;"	f
test_static_graph	stupidgraph.h	/^void test_static_graph() {$/;"	f
test_sum_tree	stupidgraph.h	/^void test_sum_tree() {$/;"	f
tree_find	stupidgraph.h	/^	N** tree_find(N** start, int key) {$/;"	f	class:BST
tree_min	stupidgraph.h	/^Node* tree_min(Node* node) {$/;"	f
tree_successor	stupidgraph.h	/^Node* tree_successor(Node* node) {$/;"	f
vertex_number	stupidgraph.h	/^	size_t vertex_number() const 	{return adj.size();}$/;"	f	class:Static_graph
weight	stupidgraph.h	/^		int weight() {return edge->weight;}$/;"	f	struct:Static_graph::Adj_iter
weight	stupidgraph.h	/^		int weight;$/;"	m	struct:Static_graph::Edge
add_list	stupidlist.cpp	/^Node* add_list(Node* head1, Node* head2) {$/;"	f
add_rev_list	stupidlist.cpp	/^Node* add_rev_list(Node* head1, Node* head2) {$/;"	f
add_rev_list_rec	stupidlist.cpp	/^Node* add_rev_list_rec(Node* head1, Node* head2, int& carry) {$/;"	f
delete_node	stupidlist.cpp	/^Node* delete_node(Node* head, Node* to_del) {$/;"	f
find_loop_start	stupidlist.cpp	/^Node* find_loop_start(Node* head) {$/;"	f
find_nth_last	stupidlist.cpp	/^Node* find_nth_last (Node* head, size_t n) {$/;"	f
init_head	stupidlist.cpp	/^Node* init_head() {$/;"	f
main	stupidlist.cpp	/^int main() {$/;"	f
operator <<	stupidlist.cpp	/^std::ostream& operator<<(std::ostream& os, Node* head) {$/;"	f
rem_dup	stupidlist.cpp	/^Node* rem_dup(Node* head) {$/;"	f
rem_dup_nobuf	stupidlist.cpp	/^Node* rem_dup_nobuf(Node* head) {$/;"	f
test_add	stupidlist.cpp	/^void test_add() {$/;"	f
test_delete	stupidlist.cpp	/^void test_delete() {$/;"	f
test_loop	stupidlist.cpp	/^void test_loop() {$/;"	f
test_nth	stupidlist.cpp	/^void test_nth() {$/;"	f
ADMIN	stupidoop.h	/^	REGULAR, PREMIUM, ADMIN, SUPERADMIN$/;"	m	class:User_type
Blackjack_card	stupidoop.h	/^	Blackjack_card(int v, Suit s) : Card{v, s} {}$/;"	f	class:Blackjack_card
Blackjack_card	stupidoop.h	/^class Blackjack_card : public Card {$/;"	c
Book	stupidoop.h	/^	Book() : id{invalid} {}$/;"	f	class:Book
Book	stupidoop.h	/^	Book(long long i, double p, std::string&& c) :$/;"	f	class:Book
Book	stupidoop.h	/^class Book {$/;"	c
Call	stupidoop.h	/^class Response {}; class Call {};$/;"	c
Call_handler	stupidoop.h	/^class Call_handler {$/;"	c
Callcenter	stupidoop.h	/^	Callcenter(Tech_lead&& tl, Product_manager&& pm) : tech_lead{tl}, product_manager{pm} {}$/;"	f	class:Callcenter
Callcenter	stupidoop.h	/^class Callcenter {$/;"	c
Card	stupidoop.h	/^	Card(int v, Suit s) : val{v}, suit{s} {}$/;"	f	class:Card
Card	stupidoop.h	/^class Card {$/;"	c
DIAMONDS	stupidoop.h	/^	HEARTS, SPADES, DIAMONDS, CLUBS$/;"	m	class:Suit
Employee	stupidoop.h	/^	Employee() {}	\/\/ default constructor in case derived classes need to be put into container$/;"	f	class:Employee
Employee	stupidoop.h	/^	Employee(const std::string& n, size_t i) : name{n}, id{i}, busy{false} {}$/;"	f	class:Employee
Employee	stupidoop.h	/^class Employee : public Call_handler {$/;"	c
Fresher	stupidoop.h	/^	Fresher() : Employee{}, workplace{nullptr} {}$/;"	f	class:Fresher
Fresher	stupidoop.h	/^	Fresher(const std::string& n, size_t i, Callcenter* w) : Employee{n,i}, workplace{w} {}$/;"	f	class:Fresher
Fresher	stupidoop.h	/^class Fresher : public Employee {$/;"	c
HEARTS	stupidoop.h	/^	HEARTS, SPADES, DIAMONDS, CLUBS$/;"	m	class:Suit
Id_hash	stupidoop.h	/^struct Id_hash {$/;"	s
Library	stupidoop.h	/^class Library {$/;"	c
PREMIUM	stupidoop.h	/^	REGULAR, PREMIUM, ADMIN, SUPERADMIN$/;"	m	class:User_type
Product_manager	stupidoop.h	/^	Product_manager(const std::string& n, size_t i) : Employee{n,i}, num_calls{0} {}$/;"	f	class:Product_manager
Product_manager	stupidoop.h	/^class Product_manager : public Employee {$/;"	c
REGULAR	stupidoop.h	/^	REGULAR, PREMIUM, ADMIN, SUPERADMIN$/;"	m	class:User_type
Response	stupidoop.h	/^class Response {}; class Call {};$/;"	c
SPADES	stupidoop.h	/^	HEARTS, SPADES, DIAMONDS, CLUBS$/;"	m	class:Suit
Suit	stupidoop.h	/^enum class Suit : char {$/;"	c
Tech_lead	stupidoop.h	/^	Tech_lead(const std::string& n, size_t i) : Employee{n,i} {}$/;"	f	class:Tech_lead
Tech_lead	stupidoop.h	/^class Tech_lead : public Employee {$/;"	c
User	stupidoop.h	/^	User() : id{invalid} {};$/;"	f	class:User
User	stupidoop.h	/^	User(const std::string& n, long long i, User_type t = User_type::REGULAR) :$/;"	f	class:User
User	stupidoop.h	/^class User {$/;"	c
User_type	stupidoop.h	/^enum class User_type : char {$/;"	c
add_balance	stupidoop.h	/^	void add_balance(double addition) {balance += addition;}$/;"	f	class:User
add_book	stupidoop.h	/^	static void add_book(Book&& book) {books()[book.get_id()] = std::move(book);}$/;"	f	class:Book
add_book	stupidoop.h	/^	static void add_book(const Book& book) {books()[book.get_id()] = book;}$/;"	f	class:Book
add_book	stupidoop.h	/^	static void add_book(long long i, double p, std::string&& c) {$/;"	f	class:Book
add_book	stupidoop.h	/^	void add_book(const Book& book) {Book::add_book(book);}$/;"	f	class:Library
add_fresher	stupidoop.h	/^	void add_fresher(const std::string& name, size_t id) {$/;"	f	class:Callcenter
add_user	stupidoop.h	/^	static void add_user(User&& user) {users()[user.get_id()] = std::move(user);}	$/;"	f	class:User
add_user	stupidoop.h	/^	static void add_user(const User& user) {users()[user.get_id()] = user;}$/;"	f	class:User
add_user	stupidoop.h	/^	static void add_user(const std::string& n, long long i, User_type t = User_type::REGULAR) {$/;"	f	class:User
add_user	stupidoop.h	/^	void add_user(const User& user) {User::add_user(user);}$/;"	f	class:Library
adjust_price	stupidoop.h	/^	void adjust_price(double new_price) {price = new_price;}$/;"	f	class:Book
available_freshers	stupidoop.h	/^	std::queue<Fresher> available_freshers;$/;"	m	class:Callcenter
available_handlers	stupidoop.h	/^	size_t available_handlers() const {$/;"	f	class:Callcenter
b	stupidoop.h	/^	Book b;$/;"	m	class:Library
balance	stupidoop.h	/^	double balance;$/;"	m	class:User
books	stupidoop.h	/^	static Book_map& books() {$/;"	f	class:Book
busy	stupidoop.h	/^	bool busy;$/;"	m	class:Employee
busy_freshers	stupidoop.h	/^	std::unordered_map<size_t,Fresher> busy_freshers;	\/\/ storage necessary since reference is returned$/;"	m	class:Callcenter
buy_book	stupidoop.h	/^	bool buy_book(size_t book_id) {$/;"	f	class:User
clear_busy	stupidoop.h	/^	void clear_busy() 	{busy = false;}$/;"	f	class:Employee
content	stupidoop.h	/^	std::string content;$/;"	m	class:Book
count_books	stupidoop.h	/^	static size_t count_books() const {$/;"	f	class:Book
count_users	stupidoop.h	/^	static size_t count_users() const {$/;"	f	class:User
emplace_book	stupidoop.h	/^	void emplace_book(Args... args) {Book::add_book(Book{args...});}$/;"	f	class:Library
emplace_user	stupidoop.h	/^	void emplace_user(Args... args) {User::add_user(User{args...});}$/;"	f	class:Library
find	stupidoop.h	/^	static Book find(size_t id) {$/;"	f	class:Book
find	stupidoop.h	/^	static User find(size_t user_id) {$/;"	f	class:User
find_book	stupidoop.h	/^	Book find_book(size_t id) const {return Book::find(id);}$/;"	f	class:Library
find_user	stupidoop.h	/^	User find_user(size_t id) const {return User::find(id);}$/;"	f	class:Library
finish_call	stupidoop.h	/^	void finish_call() {$/;"	f	class:Product_manager
finish_call	stupidoop.h	/^void Fresher::finish_call() {$/;"	f	class:Fresher
fresher_finished	stupidoop.h	/^	void fresher_finished(Fresher& fresher) {$/;"	f	class:Callcenter
get_balance	stupidoop.h	/^	double get_balance() const 	{return balance;}$/;"	f	class:User
get_book	stupidoop.h	/^	Book get_book(size_t book_id) const {$/;"	f	class:User
get_call_handler	stupidoop.h	/^	Call_handler& get_call_handler() {$/;"	f	class:Callcenter
get_id	stupidoop.h	/^	long long get_id() const 	{return id;}$/;"	f	class:User
get_id	stupidoop.h	/^	long long get_id() const {return id;}$/;"	f	class:Book
get_id	stupidoop.h	/^	size_t get_id() const {return id;}$/;"	f	class:Employee
get_price	stupidoop.h	/^	double get_price() const {return price;}$/;"	f	class:Book
get_suit	stupidoop.h	/^	Suit get_suit() {return suit;}$/;"	f	class:Card
get_val	stupidoop.h	/^	virtual int get_val() {return val;}$/;"	f	class:Card
id	stupidoop.h	/^	long long id;	$/;"	m	class:User
id	stupidoop.h	/^	long long id;$/;"	m	class:Book
id	stupidoop.h	/^	size_t id;$/;"	m	class:Employee
invalid	stupidoop.h	/^constexpr long long invalid = -1;$/;"	v
is_busy	stupidoop.h	/^	bool is_busy()  const {return busy;}$/;"	f	class:Employee
listen_request	stupidoop.h	/^	void listen_request() {}	\/\/ listen to user requests (web server)$/;"	f	class:Library
name	stupidoop.h	/^	std::string name;$/;"	m	class:Employee
name	stupidoop.h	/^	std::string name;$/;"	m	class:User
num_books	stupidoop.h	/^	size_t num_books() const {return Book::count_books();}$/;"	f	class:Library
num_calls	stupidoop.h	/^	int num_calls;$/;"	m	class:Product_manager
num_users	stupidoop.h	/^	size_t num_users() const {return User::count_users();}$/;"	f	class:Library
operator ()	stupidoop.h	/^	size_t operator()(const E& e) const {$/;"	f	struct:Id_hash
operator ==	stupidoop.h	/^	bool operator==(const Employee& other) const {return other.id == id;} \/\/ identity and hash$/;"	f	class:Employee
operator bool	stupidoop.h	/^	explicit operator bool() const {return id != invalid;}$/;"	f	class:Book
operator bool	stupidoop.h	/^	explicit operator bool() const {return id != invalid;}$/;"	f	class:User
override	stupidoop.h	/^	void finish_call() override;$/;"	m	class:Fresher
owned_books	stupidoop.h	/^	std::unordered_set<size_t> owned_books;$/;"	m	class:User
price	stupidoop.h	/^	double price;$/;"	m	class:Book
product_manager	stupidoop.h	/^	Product_manager product_manager;$/;"	m	class:Callcenter
read	stupidoop.h	/^	std::pair<std::string, size_t> read(size_t start_index, size_t chars_to_read) {$/;"	f	class:Book
remove_book	stupidoop.h	/^	static void remove_book(size_t book_id) {$/;"	f	class:Book
remove_user	stupidoop.h	/^	static void remove_user(size_t user_id) {$/;"	f	class:User
set_busy	stupidoop.h	/^	void set_busy() 	{busy = true;}$/;"	f	class:Employee
suit	stupidoop.h	/^	Suit suit;$/;"	m	class:Card
take_call	stupidoop.h	/^	int take_call() {$/;"	f	class:Product_manager
tech_lead	stupidoop.h	/^	Tech_lead tech_lead;$/;"	m	class:Callcenter
test_callcenter	stupidoop.h	/^void test_callcenter() {$/;"	f
test_cards	stupidoop.h	/^void test_cards() {$/;"	f
test_library	stupidoop.h	/^void test_library() {$/;"	f
type	stupidoop.h	/^	User_type type;$/;"	m	class:User
u	stupidoop.h	/^	User u;$/;"	m	class:Library
users	stupidoop.h	/^	static User_map& users() {$/;"	f	class:User
val	stupidoop.h	/^	int val;$/;"	m	class:Card
workplace	stupidoop.h	/^	Callcenter* workplace;	\/\/ need to be added back onto available queue after finishing call$/;"	m	class:Fresher
Queue	stupidqueue.h	/^	Queue() : front {nullptr}, back {nullptr} {}$/;"	f	class:Queue
Queue	stupidqueue.h	/^	Queue(Linked_node* n) : front {n}, back {front} {}$/;"	f	class:Queue
Queue	stupidqueue.h	/^	Queue(int d) : front {new Linked_node {d}}, back {front} {}$/;"	f	class:Queue
Queue	stupidqueue.h	/^class Queue {$/;"	c
Stack_queue	stupidqueue.h	/^	Stack_queue() {}$/;"	f	class:Stack_queue
Stack_queue	stupidqueue.h	/^class Stack_queue {$/;"	c
back	stupidqueue.h	/^	Linked_node *front, *back;$/;"	m	class:Queue
deq	stupidqueue.h	/^	std::stack<int> enq, deq;$/;"	m	class:Stack_queue
dequeue	stupidqueue.h	/^	Linked_node* dequeue() {$/;"	f	class:Queue
dequeue	stupidqueue.h	/^	int dequeue() {$/;"	f	class:Stack_queue
dumpto_deq	stupidqueue.h	/^	void dumpto_deq() {$/;"	f	class:Stack_queue
dumpto_enq	stupidqueue.h	/^	void dumpto_enq() {$/;"	f	class:Stack_queue
empty	stupidqueue.h	/^	bool empty() {$/;"	f	class:Stack_queue
enq	stupidqueue.h	/^	std::stack<int> enq, deq;$/;"	m	class:Stack_queue
enqueue	stupidqueue.h	/^	void enqueue(Linked_node* latest) {$/;"	f	class:Queue
enqueue	stupidqueue.h	/^	void enqueue(int val) {$/;"	f	class:Stack_queue
examine	stupidqueue.h	/^	void examine() {$/;"	f	class:Stack_queue
front	stupidqueue.h	/^	Linked_node *front, *back;$/;"	m	class:Queue
peek	stupidqueue.h	/^	int peek() {$/;"	f	class:Stack_queue
test_stack_queue	stupidqueue.h	/^void test_stack_queue() {$/;"	f
Hanoi_towers	stupidstack.h	/^	Hanoi_towers(size_t N) : towers(3), game_size{N}, moves_taken{0} {$/;"	f	class:Hanoi_towers
Hanoi_towers	stupidstack.h	/^class Hanoi_towers {$/;"	c
Min_stack	stupidstack.h	/^class Min_stack {$/;"	c
Stack	stupidstack.h	/^	Stack() : tp {nullptr} {}$/;"	f	class:Stack
Stack	stupidstack.h	/^	Stack(N* n) : tp {n} {}$/;"	f	class:Stack
Stack	stupidstack.h	/^	Stack(T top_data) : tp {new N {top_data}} {}$/;"	f	class:Stack
Stack	stupidstack.h	/^class Stack {$/;"	c
Stack_set	stupidstack.h	/^	Stack_set(size_t mh) : ss{std::stack<T>{}}, max_height {mh} {}$/;"	f	class:Stack_set
Stack_set	stupidstack.h	/^class Stack_set {$/;"	c
empty	stupidstack.h	/^	bool empty() {$/;"	f	class:Stack_set
examine	stupidstack.h	/^	void examine() {$/;"	f	class:Hanoi_towers
game_size	stupidstack.h	/^	size_t game_size;$/;"	m	class:Hanoi_towers
max_height	stupidstack.h	/^	size_t max_height;$/;"	m	class:Stack_set
min	stupidstack.h	/^	const Linked_node* min() {$/;"	f	class:Min_stack
mins	stupidstack.h	/^	Stack<Linked_node> mins;$/;"	m	class:Min_stack
move	stupidstack.h	/^	void move(size_t move_from, size_t move_to, size_t num_moved) {$/;"	f	class:Hanoi_towers
moves_taken	stupidstack.h	/^	size_t moves_taken;$/;"	m	class:Hanoi_towers
pop	stupidstack.h	/^	Linked_node* pop() {$/;"	f	class:Min_stack
pop	stupidstack.h	/^	N* pop() {$/;"	f	class:Stack
pop	stupidstack.h	/^	T pop() {$/;"	f	class:Stack_set
pop_at	stupidstack.h	/^	T pop_at(size_t si) {$/;"	f	class:Stack_set
print	stupidstack.h	/^	void print() {$/;"	f	class:Stack_set
push	stupidstack.h	/^	N* push(N* n) {$/;"	f	class:Stack
push	stupidstack.h	/^	N* push(T data) {$/;"	f	class:Stack
push	stupidstack.h	/^	size_t push(const T& val) {$/;"	f	class:Stack_set
push	stupidstack.h	/^	void push(Linked_node* n) {$/;"	f	class:Min_stack
push	stupidstack.h	/^	void push(T d) {return push(new Linked_node {d});}$/;"	f	class:Min_stack
solve	stupidstack.h	/^	size_t solve() {$/;"	f	class:Hanoi_towers
ss	stupidstack.h	/^	std::vector<std::stack<T>> ss;$/;"	m	class:Stack_set
test_hanoi	stupidstack.h	/^void test_hanoi() {$/;"	f
test_min_stack	stupidstack.h	/^void test_min_stack() {$/;"	f
test_stack_set	stupidstack.h	/^void test_stack_set() {$/;"	f
top	stupidstack.h	/^	const N* top() {return tp;}$/;"	f	class:Stack
towers	stupidstack.h	/^	std::vector<std::stack<int>> towers;$/;"	m	class:Hanoi_towers
main	tester.cpp	/^int main() {$/;"	f
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
